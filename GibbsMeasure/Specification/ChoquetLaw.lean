import GibbsMeasure.Specification.ErgodicDecomposition
import Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated
import Mathlib.MeasureTheory.Measure.Map
import Mathlib.MeasureTheory.PiSystem

/-!
# Choquet-style law statements for tail disintegration (Georgii, Ch. 7 ‚Äî representing measure)

This file turns œâ-a.e. statements about tail conditional measures `tailKernel Œº œâ` into statements
about their **law** `tailKernelLaw Œº = Œº.map (tailKernel Œº)`.

The key technical point is to work with **countable cores** (built from `natGeneratingSequence`):
this lets us express Gibbs fixed-point properties and tail-triviality by countably many measurable
constraints on `Measure (S ‚Üí E)`, so that we can push `‚àÄ·µê` through `Measure.map` without adding any
unmotivated topological assumptions.
-/

open Set
open scoped ENNReal ProbabilityTheory

namespace MeasureTheory

namespace GibbsMeasure

variable {S E : Type*} [MeasurableSpace E]

section CorePiSystem

variable {Œ© : Type*} [MeasurableSpace Œ©] [MeasurableSpace.CountablyGenerated Œ©]

/-- A countable family of sets generating the measurable space on `Œ©`. -/
noncomputable def natGen (Œ© : Type*) [MeasurableSpace Œ©] [MeasurableSpace.CountablyGenerated Œ©] :
    ‚Ñï ‚Üí Set Œ© :=
  MeasurableSpace.natGeneratingSequence Œ©

/-- The œÄ-system generated by `natGen`, realized as finite intersections. -/
noncomputable def piNatGen (t : Finset ‚Ñï) : Set Œ© :=
  ‚ãÇ n ‚àà t, natGen Œ© n

lemma measurableSet_piNatGen (t : Finset ‚Ñï) : MeasurableSet (piNatGen (Œ© := Œ©) t) := by
  refine Finset.measurableSet_biInter t ?_
  intro n hn
  simpa [natGen] using (MeasurableSpace.measurableSet_natGeneratingSequence (Œ± := Œ©) n)

/-- The countable œÄ-system of finite intersections of the generating sequence. -/
def piNatGenSet (Œ© : Type*) [MeasurableSpace Œ©] [MeasurableSpace.CountablyGenerated Œ©] : Set (Set Œ©) :=
  Set.range (piNatGen (Œ© := Œ©))

lemma isPiSystem_piNatGenSet : IsPiSystem (piNatGenSet Œ©) := by
  rintro s ‚ü®t, rfl‚ü© u ‚ü®v, rfl‚ü© hne
  refine ‚ü®t ‚à™ v, ?_‚ü©
  ext x
  constructor
  ¬∑ intro hx
    have hx' : ‚àÄ i, i ‚àà t ‚à™ v ‚Üí x ‚àà natGen Œ© i := by
      simpa [piNatGen] using hx
    have ht : x ‚àà piNatGen (Œ© := Œ©) t := by
      refine (by
        simpa [piNatGen] using (show ‚àÄ i, i ‚àà t ‚Üí x ‚àà natGen Œ© i from
          fun i hi => hx' i (by simp [Finset.mem_union, hi])))
    have hv : x ‚àà piNatGen (Œ© := Œ©) v := by
      simpa [piNatGen] using (show ‚àÄ i, i ‚àà v ‚Üí x ‚àà natGen Œ© i from
        fun i hi => hx' i (by simp [Finset.mem_union, hi]))
    exact ‚ü®ht, hv‚ü©
  ¬∑ rintro ‚ü®ht, hv‚ü©
    have ht' : ‚àÄ i, i ‚àà t ‚Üí x ‚àà natGen Œ© i := by simpa [piNatGen] using ht
    have hv' : ‚àÄ i, i ‚àà v ‚Üí x ‚àà natGen Œ© i := by simpa [piNatGen] using hv
    simpa [piNatGen] using (show ‚àÄ i, i ‚àà t ‚à™ v ‚Üí x ‚àà natGen Œ© i from
      fun i hi => by
        have : i ‚àà t ‚à® i ‚àà v := by simpa [Finset.mem_union] using hi
        rcases this with hi | hi
        ¬∑ exact ht' i hi
        ¬∑ exact hv' i hi)

lemma generateFrom_piNatGenSet :
    MeasurableSpace.generateFrom (piNatGenSet Œ©) = (‚ÄπMeasurableSpace Œ©‚Ä∫) := by
  have hle : MeasurableSpace.generateFrom (piNatGenSet Œ©) ‚â§ (‚ÄπMeasurableSpace Œ©‚Ä∫) := by
    refine MeasurableSpace.generateFrom_le ?_
    rintro _ ‚ü®t, rfl‚ü©
    exact measurableSet_piNatGen (Œ© := Œ©) t
  have hsub : Set.range (natGen Œ©) ‚äÜ piNatGenSet Œ© := by
    intro s hs
    rcases hs with ‚ü®n, rfl‚ü©
    refine ‚ü®{n}, ?_‚ü©
    ext x
    simp [piNatGen, natGen]
  have hge :
      (‚ÄπMeasurableSpace Œ©‚Ä∫) ‚â§ MeasurableSpace.generateFrom (piNatGenSet Œ©) := by
    have : MeasurableSpace.generateFrom (Set.range (natGen Œ©)) =
        (‚ÄπMeasurableSpace Œ©‚Ä∫) := by
      simpa [natGen] using (MeasurableSpace.generateFrom_natGeneratingSequence (Œ± := Œ©))
    have hmono :
        MeasurableSpace.generateFrom (Set.range (natGen Œ©))
          ‚â§ MeasurableSpace.generateFrom (piNatGenSet Œ©) :=
      MeasurableSpace.generateFrom_mono hsub
    simpa [this] using hmono
  exact le_antisymm hle hge

end CorePiSystem

/-! ## Measurable cores for tail-triviality and the Gibbs fixed-point property -/

section TailTrivialCore

variable [Countable S] [StandardBorelSpace E]
variable
    [@MeasurableSpace.CountableOrCountablyGenerated (S ‚Üí E) (S ‚Üí E) (@tailSigmaAlgebra S E _)]

local notation3 (prettyPrint := false) "Œ©" => (S ‚Üí E)

-- Build the countable œÄ-system inside the tail œÉ-algebra without changing the ambient `pi`-structure
-- on `Œ©` (since our measures live on `MeasurableSpace.pi`).
noncomputable def tailPiNatGen (t : Finset ‚Ñï) : Set Œ© := by
  letI : MeasurableSpace Œ© := (@tailSigmaAlgebra S E _)
  haveI : MeasurableSpace.CountablyGenerated Œ© := by
    rcases ( (inferInstance :
        MeasurableSpace.CountableOrCountablyGenerated Œ© Œ©).countableOrCountablyGenerated ) with hŒ© | hcg
    ¬∑ haveI : Countable Œ© := hŒ©
      infer_instance
    ¬∑ exact hcg
  exact piNatGen (t := t)

omit [Countable S] [StandardBorelSpace E] in
lemma measurableSet_tailPiNatGen_tail (t : Finset ‚Ñï) :
    MeasurableSet[@tailSigmaAlgebra S E _] (tailPiNatGen (S := S) (E := E) t) := by
  -- unfold the definition in the tail measurable space
  letI : MeasurableSpace Œ© := (@tailSigmaAlgebra S E _)
  haveI : MeasurableSpace.CountablyGenerated Œ© := by
    rcases ( (inferInstance :
        MeasurableSpace.CountableOrCountablyGenerated Œ© Œ©).countableOrCountablyGenerated ) with hŒ© | hcg
    ¬∑ haveI : Countable Œ© := hŒ©
      infer_instance
    ¬∑ exact hcg
  simpa [tailPiNatGen] using (@measurableSet_piNatGen (S ‚Üí E) _ _ t)

omit [Countable S] [StandardBorelSpace E] in
lemma measurableSet_tailPiNatGen_pi (t : Finset ‚Ñï) :
    MeasurableSet (tailPiNatGen (S := S) (E := E) t) := by
  -- tail sets are `pi`-measurable
  have hm : (@tailSigmaAlgebra S E _ : MeasurableSpace Œ©) ‚â§ MeasurableSpace.pi :=
    tailSigmaAlgebra_le_pi (S := S) (E := E)
  exact hm _ (measurableSet_tailPiNatGen_tail (S := S) (E := E) t)

/-- A *countable* core formulation of tail-triviality (0‚Äì1 law checked on a countable œÄ-system
generating the tail œÉ-algebra). -/
def IsTailTrivialCore (ŒΩ : Measure Œ©) : Prop :=
  ŒΩ Set.univ = 1 ‚àß
    ‚àÄ t : Finset ‚Ñï,
      ŒΩ (tailPiNatGen (S := S) (E := E) t) = 0 ‚à® ŒΩ (tailPiNatGen (S := S) (E := E) t) = 1

omit [Countable S] [StandardBorelSpace E] in
lemma measurableSet_isTailTrivialCore :
    MeasurableSet {ŒΩ : Measure Œ© | IsTailTrivialCore (S := S) (E := E) ŒΩ} := by
  have h_univ : MeasurableSet {ŒΩ : Measure Œ© | ŒΩ Set.univ = (1 : ‚Ñù‚â•0‚àû)} :=
    (MeasurableSet.singleton (1 : ‚Ñù‚â•0‚àû)).preimage (Measure.measurable_coe MeasurableSet.univ)
  have hT (t : Finset ‚Ñï) :
      MeasurableSet {ŒΩ : Measure Œ© |
        ŒΩ (tailPiNatGen (S := S) (E := E) t) = (0 : ‚Ñù‚â•0‚àû) ‚à®
          ŒΩ (tailPiNatGen (S := S) (E := E) t) = (1 : ‚Ñù‚â•0‚àû)} := by
    have h_eval :
        Measurable fun ŒΩ : Measure Œ© => ŒΩ (tailPiNatGen (S := S) (E := E) t) :=
      Measure.measurable_coe (measurableSet_tailPiNatGen_pi (S := S) (E := E) t)
    have h0 :
        MeasurableSet {ŒΩ : Measure Œ© | ŒΩ (tailPiNatGen (S := S) (E := E) t) = (0 : ‚Ñù‚â•0‚àû)} :=
      (MeasurableSet.singleton (0 : ‚Ñù‚â•0‚àû)).preimage h_eval
    have h1 :
        MeasurableSet {ŒΩ : Measure Œ© | ŒΩ (tailPiNatGen (S := S) (E := E) t) = (1 : ‚Ñù‚â•0‚àû)} :=
      (MeasurableSet.singleton (1 : ‚Ñù‚â•0‚àû)).preimage h_eval
    simpa [Set.setOf_or] using h0.union h1
  have hAll :
      MeasurableSet {ŒΩ : Measure Œ© | ‚àÄ t : Finset ‚Ñï,
        ŒΩ (tailPiNatGen (S := S) (E := E) t) = (0 : ‚Ñù‚â•0‚àû) ‚à®
          ŒΩ (tailPiNatGen (S := S) (E := E) t) = (1 : ‚Ñù‚â•0‚àû)} := by
    simpa [Set.setOf_forall] using (MeasurableSet.iInter (fun t => hT t))
  simpa [IsTailTrivialCore, Set.setOf_and, Set.setOf_forall] using h_univ.inter hAll

omit [Countable S] [StandardBorelSpace E] in
lemma isTailTrivial_of_isTailTrivialCore {ŒΩ : Measure Œ©}
    (hcore : IsTailTrivialCore (S := S) (E := E) ŒΩ) :
    IsTailTrivial (S := S) (E := E) (‚ü®ŒΩ, ‚ü®hcore.1‚ü©‚ü© : ProbabilityMeasure Œ©) := by
  -- Work with the trimmed measure on the tail œÉ-algebra and apply Dynkin œÄ-Œª induction.
  let hm : (@tailSigmaAlgebra S E _ : MeasurableSpace Œ©) ‚â§ MeasurableSpace.pi :=
    tailSigmaAlgebra_le_pi (S := S) (E := E)
  let ŒΩt : Measure[@tailSigmaAlgebra S E _] Œ© := (ŒΩ.trim hm)
  have hŒΩt_univ : ŒΩt Set.univ = (1 : ‚Ñù‚â•0‚àû) := by
    have : (ŒΩ.trim hm) (Set.univ : Set Œ©) = ŒΩ (Set.univ : Set Œ©) :=
      MeasureTheory.trim_measurableSet_eq (Œº := ŒΩ) hm (MeasurableSet.univ :
        MeasurableSet[@tailSigmaAlgebra S E _] (Set.univ : Set Œ©))
    simpa [ŒΩt] using this.trans hcore.1
  have hŒΩt_core : ‚àÄ t : Finset ‚Ñï,
      ŒΩt (tailPiNatGen (S := S) (E := E) t) = 0 ‚à® ŒΩt (tailPiNatGen (S := S) (E := E) t) = 1 := by
    intro t
    have ht : MeasurableSet[@tailSigmaAlgebra S E _] (tailPiNatGen (S := S) (E := E) t) :=
      measurableSet_tailPiNatGen_tail (S := S) (E := E) t
    have : (ŒΩ.trim hm) (tailPiNatGen (S := S) (E := E) t) = ŒΩ (tailPiNatGen (S := S) (E := E) t) :=
      MeasureTheory.trim_measurableSet_eq (Œº := ŒΩ) hm ht
    rcases hcore.2 t with ht0 | ht1
    ¬∑ left; simp [ŒΩt, this, ht0]
    ¬∑ right; simp [ŒΩt, this, ht1]
  -- Dynkin induction on the tail œÉ-algebra generated by the œÄ-system core.
  haveI : IsProbabilityMeasure ŒΩt := ‚ü®hŒΩt_univ‚ü©
  -- Define the generating œÄ-system `C` *inside* the tail œÉ-algebra.
  let C : Set (Set Œ©) := by
    letI : MeasurableSpace Œ© := (@tailSigmaAlgebra S E _)
    haveI : MeasurableSpace.CountablyGenerated Œ© := by
      rcases ( (inferInstance :
          MeasurableSpace.CountableOrCountablyGenerated Œ© Œ©).countableOrCountablyGenerated ) with hŒ© | hcg
      ¬∑ haveI : Countable Œ© := hŒ©
        infer_instance
      ¬∑ exact hcg
    exact piNatGenSet Œ©
  have h_eq : (@tailSigmaAlgebra S E _ : MeasurableSpace Œ©) =
      MeasurableSpace.generateFrom C := by
    letI : MeasurableSpace Œ© := (@tailSigmaAlgebra S E _)
    haveI : MeasurableSpace.CountablyGenerated Œ© := by
      rcases ( (inferInstance :
          MeasurableSpace.CountableOrCountablyGenerated Œ© Œ©).countableOrCountablyGenerated ) with hŒ© | hcg
      ¬∑ haveI : Countable Œ© := hŒ©
        infer_instance
      ¬∑ exact hcg
    have : MeasurableSpace.generateFrom (piNatGenSet Œ©) = (‚ÄπMeasurableSpace Œ©‚Ä∫) :=
      (@generateFrom_piNatGenSet (S ‚Üí E) _ _)
    simpa [C] using this.symm
  have hPi : IsPiSystem C := by
    letI : MeasurableSpace Œ© := (@tailSigmaAlgebra S E _)
    haveI : MeasurableSpace.CountablyGenerated Œ© := by
      rcases ( (inferInstance :
          MeasurableSpace.CountableOrCountablyGenerated Œ© Œ©).countableOrCountablyGenerated ) with hŒ© | hcg
      ¬∑ haveI : Countable Œ© := hŒ©
        infer_instance
      ¬∑ exact hcg
    simpa [C] using (@isPiSystem_piNatGenSet (S ‚Üí E) _ _)
  intro A hA
  have hA_pi : MeasurableSet A := hm _ hA
  have h01_t : ŒΩt A = 0 ‚à® ŒΩt A = 1 := by
    refine MeasurableSpace.induction_on_inter
      (m := (@tailSigmaAlgebra S E _ : MeasurableSpace Œ©))
      (s := C) h_eq hPi
      (C := fun s _ => ŒΩt s = (0 : ‚Ñù‚â•0‚àû) ‚à® ŒΩt s = (1 : ‚Ñù‚â•0‚àû))
      (empty := by simp)
      (basic := fun t ht => by
        rcases ht with ‚ü®u, rfl‚ü©
        -- by construction, `piNatGen` in the tail instance is `tailPiNatGen`
        simpa [tailPiNatGen] using hŒΩt_core u)
      (compl := fun t htm ht01 => by
        rcases ht01 with ht0 | ht1
        ¬∑ right
          have : ŒΩt t·∂ú = ŒΩt Set.univ - ŒΩt t := by
            simpa using (MeasureTheory.measure_compl (Œº := ŒΩt) htm (by simp))
          simp [this, hŒΩt_univ, ht0]
        ¬∑ left
          have : ŒΩt t·∂ú = ŒΩt Set.univ - ŒΩt t := by
            simpa using (MeasureTheory.measure_compl (Œº := ŒΩt) htm (by simp))
          simp [this, hŒΩt_univ, ht1])
      (iUnion := fun f hdisj hfm hf01 => by
        by_cases h1 : ‚àÉ i, ŒΩt (f i) = (1 : ‚Ñù‚â•0‚àû)
        ¬∑ rcases h1 with ‚ü®i, hi‚ü©
          right
          have hle : (1 : ‚Ñù‚â•0‚àû) ‚â§ ŒΩt (‚ãÉ i, f i) := by
            have : ŒΩt (f i) ‚â§ ŒΩt (‚ãÉ i, f i) :=
              measure_mono (by intro x hx; exact mem_iUnion.2 ‚ü®i, hx‚ü©)
            simpa [hi] using this
          have hge : ŒΩt (‚ãÉ i, f i) ‚â§ (1 : ‚Ñù‚â•0‚àû) := by
            have : ŒΩt (‚ãÉ i, f i) ‚â§ ŒΩt Set.univ :=
              measure_mono (subset_univ (‚ãÉ i, f i))
            simpa [hŒΩt_univ] using this
          exact le_antisymm hge hle
        ¬∑ left
          have h0 : ‚àÄ i, ŒΩt (f i) = (0 : ‚Ñù‚â•0‚àû) := by
            intro i
            rcases hf01 i with hi0 | hi1
            ¬∑ exact hi0
            ¬∑ exact (False.elim (h1 ‚ü®i, hi1‚ü©))
          have hle : ŒΩt (‚ãÉ i, f i) ‚â§ (0 : ‚Ñù‚â•0‚àû) := by
            have : ŒΩt (‚ãÉ i, f i) ‚â§ ‚àë' i, ŒΩt (f i) := by
              simpa using (measure_iUnion_le (Œº := ŒΩt) (s := f))
            simp [h0]
          exact (le_antisymm hle (zero_le _)))
      A hA
  simpa [ŒΩt, MeasureTheory.trim_measurableSet_eq (Œº := ŒΩ) hm hA] using h01_t

omit [Countable S] [StandardBorelSpace E] in
lemma isTailTrivialCore_of_isTailTrivial {ŒΩ : Measure Œ©} [IsProbabilityMeasure ŒΩ]
    (h : IsTailTrivial (S := S) (E := E) (‚ü®ŒΩ, inferInstance‚ü© : ProbabilityMeasure Œ©)) :
    IsTailTrivialCore (S := S) (E := E) ŒΩ := by
  refine ‚ü®by simp, ?_‚ü©
  intro t
  -- `tailPiNatGen t` is a tail event
  have ht : MeasurableSet[@tailSigmaAlgebra S E _] (tailPiNatGen (S := S) (E := E) t) :=
    measurableSet_tailPiNatGen_tail (S := S) (E := E) t
  simpa using h (tailPiNatGen (S := S) (E := E) t) ht

end TailTrivialCore

section GibbsCore

open ProbabilityTheory

variable [Countable S] [StandardBorelSpace E]
local notation3 (prettyPrint := false) "Œ©" => (S ‚Üí E)

variable (Œ≥ : Specification S E) [Œ≥.IsMarkov]

-- `Œ©` is countably generated (needed for `natGeneratingSequence` on the product œÉ-algebra).
local instance : MeasurableSpace.CountablyGenerated Œ© := by infer_instance

/-- A *countable* core formulation of the DLR fixed-point property:
check `Œº.bind (Œ≥ Œõ) = Œº` on a countable œÄ-system generating the full œÉ-algebra. -/
def IsGibbsCore (Œ≥ : Specification S E) (Œº : Measure Œ©) : Prop :=
  Œº Set.univ = 1 ‚àß
    ‚àÄ (Œõ : Finset S) (t : Finset ‚Ñï),
      (Œº.bind (Œ≥ Œõ)) (piNatGen (t := t)) = Œº (piNatGen (t := t))

omit [Œ≥.IsMarkov] in
lemma measurableSet_isGibbsCore :
    MeasurableSet {Œº : Measure Œ© | IsGibbsCore (Œ≥ := Œ≥) Œº} := by
  have h_univ : MeasurableSet {Œº : Measure Œ© | Œº Set.univ = (1 : ‚Ñù‚â•0‚àû)} :=
    (MeasurableSet.singleton (1 : ‚Ñù‚â•0‚àû)).preimage (Measure.measurable_coe MeasurableSet.univ)
  have hEq' (Œõ : Finset S) (t : Finset ‚Ñï) :
      MeasurableSet {Œº : Measure Œ© |
        (Œº.bind (Œ≥ Œõ)) (piNatGen (t := t)) = Œº (piNatGen (t := t))} := by
    have hŒ≥meas : Measurable fun œâ : Œ© => (Œ≥ Œõ œâ : Measure Œ©) := by
      exact (Kernel.measurable (Œ≥ Œõ)).mono
        (MeasureTheory.cylinderEvents_le_pi (X := fun _ : S ‚Ü¶ E) (Œî := ((Œõ : Set S)·∂ú))) le_rfl
    have hbind : Measurable fun Œº : Measure Œ© => Œº.bind (fun œâ => (Œ≥ Œõ œâ : Measure Œ©)) :=
      _root_.MeasureTheory.Measure.measurable_bind' hŒ≥meas
    have h_eval : Measurable fun Œº : Measure Œ© => Œº (piNatGen (t := t)) :=
      Measure.measurable_coe (measurableSet_piNatGen (t := t))
    have hL : Measurable fun Œº : Measure Œ© => (Œº.bind (fun œâ => (Œ≥ Œõ œâ : Measure Œ©))) (piNatGen (t := t)) :=
      h_eval.comp hbind
    exact measurableSet_eq_fun hL h_eval
  have hAll :
      MeasurableSet {Œº : Measure Œ© | ‚àÄ Œõ : Finset S, ‚àÄ t : Finset ‚Ñï,
        (Œº.bind (Œ≥ Œõ)) (piNatGen (t := t)) = Œº (piNatGen (t := t))} := by
    simpa [Set.setOf_forall] using
      (MeasurableSet.iInter (fun (Œõ : Finset S) =>
        (MeasurableSet.iInter (fun (t : Finset ‚Ñï) => hEq' (Œõ := Œõ) (t := t)))))
  simpa [IsGibbsCore, Set.setOf_and, Set.setOf_forall] using h_univ.inter hAll

theorem isGibbsMeasure_of_isGibbsCore (hŒ≥ : Œ≥.IsProper) {Œº : Measure Œ©}
    (hcore : IsGibbsCore (Œ≥ := Œ≥) Œº) :
    _root_.Specification.IsGibbsMeasure (S := S) (E := E) Œ≥ Œº := by
  have hŒº_univ : Œº Set.univ = 1 := hcore.1
  haveI : IsProbabilityMeasure Œº := ‚ü®hŒº_univ‚ü©
  -- show the fixed-point identity for every finite volume
  have hfix : ‚àÄ Œõ : Finset S, Œº.bind (Œ≥ Œõ) = Œº := by
    intro Œõ
    -- equality of finite measures from equality on a generating œÄ-system
    let C : Set (Set Œ©) := piNatGenSet Œ©
    have hA : (MeasurableSpace.pi : MeasurableSpace Œ©) = MeasurableSpace.generateFrom C := by
      -- `generateFrom C = pi`
      simpa [C] using (@generateFrom_piNatGenSet Œ© _ _).symm
    have hC : IsPiSystem C := by
      simpa [C] using (@isPiSystem_piNatGenSet Œ© _ _)
    have hŒºŒΩ : ‚àÄ s ‚àà C, (Œº.bind (Œ≥ Œõ)) s = Œº s := by
      intro s hs
      rcases hs with ‚ü®t, rfl‚ü©
      simpa using hcore.2 Œõ t
    have hŒ≥meas : Measurable fun œâ : Œ© => (Œ≥ Œõ œâ : Measure Œ©) := by
      exact (Kernel.measurable (Œ≥ Œõ)).mono
        (MeasureTheory.cylinderEvents_le_pi (X := fun _ : S ‚Ü¶ E) (Œî := ((Œõ : Set S)·∂ú))) le_rfl
    have huniv : (Œº.bind (Œ≥ Œõ)) Set.univ = Œº Set.univ := by
      -- `bind_apply` + Markov property of `Œ≥ Œõ`
      simp [MeasureTheory.Measure.bind_apply (m := Œº) (f := fun œâ : Œ© => (Œ≥ Œõ œâ : Measure Œ©))
        (s := (Set.univ : Set Œ©)) MeasurableSet.univ hŒ≥meas.aemeasurable]
    haveI : IsFiniteMeasure (Œº.bind (Œ≥ Œõ)) := by
      refine ‚ü®?_‚ü©
      -- `Œº.bind (Œ≥ Œõ)` is a probability measure since `Œº` is and `Œ≥ Œõ` is Markov
      have : (Œº.bind (Œ≥ Œõ)) Set.univ = 1 := by simpa [hŒº_univ] using huniv
      simpa [this] using (ENNReal.one_lt_top)
    -- `ext_of_generate_finite` (finite measures, œÄ-system)
    exact MeasureTheory.ext_of_generate_finite C hA hC (Œº := (Œº.bind (Œ≥ Œõ))) (ŒΩ := Œº) hŒºŒΩ huniv
  -- use the fixed-point characterization
  exact (Specification.isGibbsMeasure_iff_forall_bind_eq (S := S) (E := E) (Œ≥ := Œ≥) hŒ≥).2 hfix

theorem isGibbsCore_of_isGibbsMeasure (hŒ≥ : Œ≥.IsProper) {Œº : Measure Œ©} [IsProbabilityMeasure Œº]
    (hŒº : _root_.Specification.IsGibbsMeasure (S := S) (E := E) Œ≥ Œº) :
    IsGibbsCore (Œ≥ := Œ≥) Œº := by
  refine ‚ü®by simp, ?_‚ü©
  have hfix :
      ‚àÄ Œõ : Finset S, Œº.bind (Œ≥ Œõ) = Œº := by
    exact (Specification.isGibbsMeasure_iff_forall_bind_eq (S := S) (E := E) (Œ≥ := Œ≥) hŒ≥).1 hŒº
  intro Œõ t
  simpa using congrArg (fun m : Measure Œ© => m (piNatGen (t := t))) (hfix Œõ)

end GibbsCore

/-! ## From œâ-a.e. extremality to law-level extremality -/

section LawLevelExtremal

open ProbabilityTheory

variable [Countable S] [StandardBorelSpace E]

variable {Œ≥ : Specification S E} [Œ≥.IsMarkov]
variable (Œº : Measure (S ‚Üí E)) [IsProbabilityMeasure Œº]

-- The tail disintegration (and `tailKernelLaw`) is built under these standard assumptions.
local instance : IsFiniteMeasure Œº := by infer_instance

variable
    [@MeasurableSpace.CountableOrCountablyGenerated (S ‚Üí E) (S ‚Üí E) (@tailSigmaAlgebra S E _)]

/-- A measurable ‚Äúgood‚Äù set of measures: those satisfying the *countable* Gibbs fixed-point core
and the *countable* tail-triviality core. This is the measurable surrogate for ‚Äúsupported on
extremal Gibbs measures‚Äù. -/
def goodSet (Œ≥ : Specification S E) : Set (Measure (S ‚Üí E)) :=
  {ŒΩ | IsGibbsCore (S := S) (E := E) (Œ≥ := Œ≥) ŒΩ ‚àß IsTailTrivialCore (S := S) (E := E) ŒΩ}

lemma measurableSet_goodSet (Œ≥ : Specification S E) [Œ≥.IsMarkov] :
    MeasurableSet (goodSet (S := S) (E := E) Œ≥) := by
  have hg : MeasurableSet {ŒΩ : Measure (S ‚Üí E) | IsGibbsCore (S := S) (E := E) (Œ≥ := Œ≥) ŒΩ} :=
    measurableSet_isGibbsCore (S := S) (E := E) (Œ≥ := Œ≥)
  have ht : MeasurableSet {ŒΩ : Measure (S ‚Üí E) | IsTailTrivialCore (S := S) (E := E) ŒΩ} :=
    measurableSet_isTailTrivialCore (S := S) (E := E)
  simpa [goodSet, Set.setOf_and] using hg.inter ht

/-- The law of tail-conditionals is concentrated on extremal Gibbs measures. -/
theorem ae_mem_extremePoints_G_tailKernelLaw
    (hŒ≥ : Œ≥.IsProper) (hŒº : Œ≥.IsGibbsMeasure Œº) :
    ‚àÄ·µê ŒΩ ‚àÇtailKernelLaw (S := S) (E := E) (Œº := Œº),
      ŒΩ ‚àà (G (Œ≥ := Œ≥)).extremePoints ENNReal := by
  have hgood_meas : MeasurableSet (goodSet (S := S) (E := E) Œ≥) :=
    measurableSet_goodSet (S := S) (E := E) (Œ≥ := Œ≥)
  -- First: show `tailKernel Œº œâ ‚àà good` for `Œº.trim ùì£`-a.e. `œâ`.
  have hae_trim :
      ‚àÄ·µê œâ ‚àÇŒº.trim (tailSigmaAlgebra_le_pi (S := S) (E := E)),
        goodSet (S := S) (E := E) Œ≥ (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by
    have haeG := ae_isGibbsMeasure_tailKernel (S := S) (E := E) (Œ≥ := Œ≥) (Œº := Œº)
      (hŒ≥ := hŒ≥) (hŒº := hŒº)
    have haeT := ae_isTailTrivial_tailKernel (S := S) (E := E) (Œº := Œº)
    filter_upwards [haeG, haeT] with œâ hG hT
    -- translate to the countable cores (for measurability)
    have hGcore :
        IsGibbsCore (S := S) (E := E) (Œ≥ := Œ≥) (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by
      haveI : IsProbabilityMeasure (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by infer_instance
      exact isGibbsCore_of_isGibbsMeasure (S := S) (E := E) (Œ≥ := Œ≥) (hŒ≥ := hŒ≥)
        (Œº := tailKernel (S := S) (E := E) (Œº := Œº) œâ) hG
    have hTcore :
        IsTailTrivialCore (S := S) (E := E) (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by
      haveI : IsProbabilityMeasure (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by infer_instance
      exact isTailTrivialCore_of_isTailTrivial (S := S) (E := E)
        (ŒΩ := tailKernel (S := S) (E := E) (Œº := Œº) œâ) hT
    exact ‚ü®hGcore, hTcore‚ü©
  -- Lift from `Œº.trim ùì£` to `Œº` (so we can use `map`).
  have hae :
      ‚àÄ·µê œâ ‚àÇŒº, goodSet (S := S) (E := E) Œ≥ (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by
    exact MeasureTheory.ae_of_ae_trim (hm := tailSigmaAlgebra_le_pi (S := S) (E := E)) (Œº := Œº) hae_trim
  -- Push forward along `tailKernel` to the law `tailKernelLaw Œº = Œº.map (tailKernel Œº)`.
  have hker_meas : AEMeasurable (tailKernel (S := S) (E := E) (Œº := Œº)) Œº := by
    exact (measurable_tailKernel_pi (S := S) (E := E) (Œº := Œº)).aemeasurable
  have hae_law :
      ‚àÄ·µê ŒΩ ‚àÇŒº.map (tailKernel (S := S) (E := E) (Œº := Œº)),
        goodSet (S := S) (E := E) Œ≥ ŒΩ := by
    -- specify the predicate explicitly to avoid unwanted `and`-splitting
    exact (MeasureTheory.ae_map_iff (Œº := Œº)
      (f := tailKernel (S := S) (E := E) (Œº := Œº)) hker_meas
      (p := fun ŒΩ => goodSet (S := S) (E := E) Œ≥ ŒΩ) (hp := hgood_meas)).2 hae
  -- Finally, on `good` we can upgrade to `ŒΩ ‚àà extremePoints G(Œ≥)`.
  have hae_ext :
      ‚àÄ·µê ŒΩ ‚àÇŒº.map (tailKernel (S := S) (E := E) (Œº := Œº)),
        ŒΩ ‚àà (G (Œ≥ := Œ≥)).extremePoints ENNReal := by
    filter_upwards [hae_law] with ŒΩ hŒΩ
    have hŒΩGibbs : _root_.Specification.IsGibbsMeasure (S := S) (E := E) Œ≥ ŒΩ :=
      isGibbsMeasure_of_isGibbsCore (S := S) (E := E) (Œ≥ := Œ≥) (hŒ≥ := hŒ≥) hŒΩ.1
    haveI : IsProbabilityMeasure ŒΩ := ‚ü®hŒΩ.1.1‚ü©
    have hŒΩ_memG : ŒΩ ‚àà G (Œ≥ := Œ≥) := by
      exact ‚ü®by infer_instance, hŒΩGibbs‚ü©
    have hŒΩ_tail : IsTailTrivial (S := S) (E := E) (‚ü®ŒΩ, inferInstance‚ü© : ProbabilityMeasure (S ‚Üí E)) :=
      isTailTrivial_of_isTailTrivialCore (S := S) (E := E) (ŒΩ := ŒΩ) hŒΩ.2
    exact mem_extremePoints_G_of_isTailTrivial (S := S) (E := E) (Œ≥ := Œ≥) (hŒ≥ := hŒ≥)
      (hŒºG := hŒΩ_memG) (hŒºtail := hŒΩ_tail)
  -- Rewrite `tailKernelLaw` and conclude.
  simpa [tailKernelLaw] using hae_ext

/-! ### A measurable ‚Äúsupport = 1‚Äù corollary -/

/-- The representing law gives full mass to the measurable `goodSet Œ≥`. -/
theorem tailKernelLaw_goodSet_eq_one
    (hŒ≥ : Œ≥.IsProper) (hŒº : Œ≥.IsGibbsMeasure Œº) :
    tailKernelLaw (S := S) (E := E) (Œº := Œº) (goodSet (S := S) (E := E) Œ≥) = 1 := by
  have hgood_meas : MeasurableSet (goodSet (S := S) (E := E) Œ≥) :=
    measurableSet_goodSet (S := S) (E := E) (Œ≥ := Œ≥)
  -- Re-run the map-pushforward step but with predicate `ŒΩ ‚àà goodSet Œ≥`.
  have hae_trim :
      ‚àÄ·µê œâ ‚àÇŒº.trim (tailSigmaAlgebra_le_pi (S := S) (E := E)),
        goodSet (S := S) (E := E) Œ≥ (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by
    have haeG := ae_isGibbsMeasure_tailKernel (S := S) (E := E) (Œ≥ := Œ≥) (Œº := Œº)
      (hŒ≥ := hŒ≥) (hŒº := hŒº)
    have haeT := ae_isTailTrivial_tailKernel (S := S) (E := E) (Œº := Œº)
    filter_upwards [haeG, haeT] with œâ hG hT
    have hGcore :
        IsGibbsCore (S := S) (E := E) (Œ≥ := Œ≥) (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by
      haveI : IsProbabilityMeasure (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by infer_instance
      exact isGibbsCore_of_isGibbsMeasure (S := S) (E := E) (Œ≥ := Œ≥) (hŒ≥ := hŒ≥)
        (Œº := tailKernel (S := S) (E := E) (Œº := Œº) œâ) hG
    have hTcore :
        IsTailTrivialCore (S := S) (E := E) (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by
      haveI : IsProbabilityMeasure (tailKernel (S := S) (E := E) (Œº := Œº) œâ) := by infer_instance
      exact isTailTrivialCore_of_isTailTrivial (S := S) (E := E)
        (ŒΩ := tailKernel (S := S) (E := E) (Œº := Œº) œâ) hT
    exact ‚ü®hGcore, hTcore‚ü©
  have hae :
      ‚àÄ·µê œâ ‚àÇŒº, goodSet (S := S) (E := E) Œ≥ (tailKernel (S := S) (E := E) (Œº := Œº) œâ) :=
    MeasureTheory.ae_of_ae_trim (hm := tailSigmaAlgebra_le_pi (S := S) (E := E)) (Œº := Œº) hae_trim
  have hker_meas : AEMeasurable (tailKernel (S := S) (E := E) (Œº := Œº)) Œº :=
    (measurable_tailKernel_pi (S := S) (E := E) (Œº := Œº)).aemeasurable
  have hae_law :
      ‚àÄ·µê ŒΩ ‚àÇŒº.map (tailKernel (S := S) (E := E) (Œº := Œº)),
        ŒΩ ‚àà goodSet (S := S) (E := E) Œ≥ :=
    (MeasureTheory.ae_map_iff (Œº := Œº) (f := tailKernel (S := S) (E := E) (Œº := Œº))
      hker_meas (p := fun ŒΩ => ŒΩ ‚àà goodSet (S := S) (E := E) Œ≥) (hp := hgood_meas)).2 hae
  haveI : IsProbabilityMeasure (tailKernelLaw (S := S) (E := E) (Œº := Œº)) :=
    isProbabilityMeasure_tailKernelLaw (S := S) (E := E) (Œº := Œº)
  have hcompl0 : tailKernelLaw (S := S) (E := E) (Œº := Œº) (goodSet (S := S) (E := E) Œ≥)·∂ú = 0 := by
    have : tailKernelLaw (S := S) (E := E) (Œº := Œº) {ŒΩ | ¬¨ ŒΩ ‚àà goodSet (S := S) (E := E) Œ≥} = 0 :=
      (MeasureTheory.ae_iff).1 (by simpa [tailKernelLaw] using hae_law)
    simpa using this
  exact (prob_compl_eq_zero_iff (Œº := tailKernelLaw (S := S) (E := E) (Œº := Œº)) hgood_meas).1 hcompl0

end LawLevelExtremal

/-! ## Georgii-style Choquet decomposition package -/

section ChoquetDecomposition

open ProbabilityTheory

variable {S E : Type*} [MeasurableSpace E]
variable [Countable S] [StandardBorelSpace E]
variable {Œ≥ : Specification S E} [Œ≥.IsMarkov]

variable (Œº : Measure (S ‚Üí E)) [IsProbabilityMeasure Œº]
variable
    [@MeasurableSpace.CountableOrCountablyGenerated (S ‚Üí E) (S ‚Üí E) (@tailSigmaAlgebra S E _)]

/-- **Choquet/ergodic decomposition (tail disintegration form)**:

If `Œº` is Gibbs, then the law `tailKernelLaw Œº` has barycenter `Œº` and is concentrated on the
measurable `goodSet Œ≥` (hence, in particular, yields `tailKernelLaw Œº`-a.e. extremality).

This is the Mathlib-idiomatic package corresponding to Georgii Ch. 7 (extremal decomposition via
tail disintegration).
-/
theorem choquetDecomposition_tailKernelLaw
    (hŒ≥ : Œ≥.IsProper) (hŒº : Œ≥.IsGibbsMeasure Œº) :
    MeasureTheory.Measure.join (tailKernelLaw (S := S) (E := E) (Œº := Œº)) = Œº
      ‚àß
    tailKernelLaw (S := S) (E := E) (Œº := Œº) (goodSet (S := S) (E := E) (Œ≥ := Œ≥)) = 1 := by
  haveI : IsFiniteMeasure Œº := by infer_instance
  refine ‚ü®?_, ?_‚ü©
  ¬∑ simpa using (join_tailKernelLaw (S := S) (E := E) (Œº := Œº))
  ¬∑ exact tailKernelLaw_goodSet_eq_one (S := S) (E := E) (Œ≥ := Œ≥) (Œº := Œº) hŒ≥ hŒº

/-- Corollary of `choquetDecomposition_tailKernelLaw`: the representing law is a.e. supported on
extreme points of `G(Œ≥)`. -/
theorem choquetDecomposition_tailKernelLaw_ae_extremePoints
    (hŒ≥ : Œ≥.IsProper) (hŒº : Œ≥.IsGibbsMeasure Œº) :
    ‚àÄ·µê ŒΩ ‚àÇtailKernelLaw (S := S) (E := E) (Œº := Œº),
      ŒΩ ‚àà (G (Œ≥ := Œ≥)).extremePoints ENNReal :=
  ae_mem_extremePoints_G_tailKernelLaw (S := S) (E := E) (Œ≥ := Œ≥) (Œº := Œº) hŒ≥ hŒº

end ChoquetDecomposition

section ChoquetDecompositionPM

open ProbabilityTheory

variable {S E : Type*} [MeasurableSpace E]
variable [Countable S] [StandardBorelSpace E]
variable {Œ≥ : Specification S E} [Œ≥.IsMarkov]

variable (Œº : ProbabilityMeasure (S ‚Üí E))
variable
    [@MeasurableSpace.CountableOrCountablyGenerated (S ‚Üí E) (S ‚Üí E) (@tailSigmaAlgebra S E _)]

/-- `ProbabilityMeasure`-packaged version of `ae_mem_extremePoints_G_tailKernelLaw`. -/
theorem ae_mem_extremePoints_G_tailKernelLawPM
    (hŒ≥ : Œ≥.IsProper) (hŒº : Œ≥.IsGibbsMeasure (Œº : Measure (S ‚Üí E))) :
    ‚àÄ·µê ŒΩ ‚àÇ(tailKernelLawPM (S := S) (E := E) Œº : Measure (Measure (S ‚Üí E))),
      ŒΩ ‚àà (G (Œ≥ := Œ≥)).extremePoints ENNReal := by
  simpa [tailKernelLawPM] using
    (ae_mem_extremePoints_G_tailKernelLaw (S := S) (E := E) (Œ≥ := Œ≥)
      (Œº := (Œº : Measure (S ‚Üí E))) hŒ≥ hŒº)

/-- `ProbabilityMeasure`-packaged version of `choquetDecomposition_tailKernelLaw`. -/
theorem choquetDecomposition_tailKernelLawPM
    (hŒ≥ : Œ≥.IsProper) (hŒº : Œ≥.IsGibbsMeasure (Œº : Measure (S ‚Üí E))) :
    MeasureTheory.Measure.join (tailKernelLaw (S := S) (E := E) (Œº := (Œº : Measure (S ‚Üí E))))
        = (Œº : Measure (S ‚Üí E))
      ‚àß
    (‚àÄ·µê ŒΩ ‚àÇ(tailKernelLawPM (S := S) (E := E) Œº : Measure (Measure (S ‚Üí E))),
      ŒΩ ‚àà (G (Œ≥ := Œ≥)).extremePoints ENNReal) := by
  haveI : IsFiniteMeasure (Œº : Measure (S ‚Üí E)) := by infer_instance
  refine ‚ü®?_, ?_‚ü©
  ¬∑ simpa using (join_tailKernelLaw (S := S) (E := E) (Œº := (Œº : Measure (S ‚Üí E))))
  ¬∑ exact ae_mem_extremePoints_G_tailKernelLawPM (S := S) (E := E) (Œ≥ := Œ≥) (Œº := Œº) hŒ≥ hŒº

/-- `ProbabilityMeasure`-bundled `goodSet` concentration statement. -/
theorem choquetDecomposition_tailKernelLawPM_goodSet
    (hŒ≥ : Œ≥.IsProper) (hŒº : Œ≥.IsGibbsMeasure (Œº : Measure (S ‚Üí E))) :
    MeasureTheory.Measure.join (tailKernelLaw (S := S) (E := E) (Œº := (Œº : Measure (S ‚Üí E))))
        = (Œº : Measure (S ‚Üí E))
      ‚àß
    tailKernelLaw (S := S) (E := E) (Œº := (Œº : Measure (S ‚Üí E)))
        (goodSet (S := S) (E := E) (Œ≥ := Œ≥)) = 1 := by
  haveI : IsProbabilityMeasure (Œº : Measure (S ‚Üí E)) := by infer_instance
  haveI : IsFiniteMeasure (Œº : Measure (S ‚Üí E)) := by infer_instance
  refine ‚ü®?_, ?_‚ü©
  ¬∑ simpa using (join_tailKernelLaw (S := S) (E := E) (Œº := (Œº : Measure (S ‚Üí E))))
  ¬∑ exact tailKernelLaw_goodSet_eq_one (S := S) (E := E) (Œ≥ := Œ≥) (Œº := (Œº : Measure (S ‚Üí E))) hŒ≥ hŒº

end ChoquetDecompositionPM

end GibbsMeasure

end MeasureTheory
