import GibbsMeasure.Specification.ErgodicDecomposition
import Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated
import Mathlib.MeasureTheory.Measure.Map
import Mathlib.MeasureTheory.PiSystem

/-!
# Choquet-style law statements for tail disintegration (Georgii, Ch. 7 — representing measure)

This file turns ω-a.e. statements about tail conditional measures `tailKernel μ ω` into statements
about their **law** `tailKernelLaw μ = μ.map (tailKernel μ)`.

The key technical point is to work with **countable cores** (built from `natGeneratingSequence`):
this lets us express Gibbs fixed-point properties and tail-triviality by countably many measurable
constraints on `Measure (S → E)`, so that we can push `∀ᵐ` through `Measure.map` without adding any
unmotivated topological assumptions.
-/

open Set
open scoped ENNReal ProbabilityTheory

namespace MeasureTheory

namespace GibbsMeasure

variable {S E : Type*} [MeasurableSpace E]

section CorePiSystem

variable {Ω : Type*} [MeasurableSpace Ω] [MeasurableSpace.CountablyGenerated Ω]

/-- A countable family of sets generating the measurable space on `Ω`. -/
noncomputable def natGen (Ω : Type*) [MeasurableSpace Ω] [MeasurableSpace.CountablyGenerated Ω] :
    ℕ → Set Ω :=
  MeasurableSpace.natGeneratingSequence Ω

/-- The π-system generated by `natGen`, realized as finite intersections. -/
noncomputable def piNatGen (t : Finset ℕ) : Set Ω :=
  ⋂ n ∈ t, natGen Ω n

lemma measurableSet_piNatGen (t : Finset ℕ) : MeasurableSet (piNatGen (Ω := Ω) t) := by
  refine Finset.measurableSet_biInter t ?_
  intro n hn
  simpa [natGen] using (MeasurableSpace.measurableSet_natGeneratingSequence (α := Ω) n)

/-- The countable π-system of finite intersections of the generating sequence. -/
def piNatGenSet (Ω : Type*) [MeasurableSpace Ω] [MeasurableSpace.CountablyGenerated Ω] : Set (Set Ω) :=
  Set.range (piNatGen (Ω := Ω))

lemma isPiSystem_piNatGenSet : IsPiSystem (piNatGenSet Ω) := by
  rintro s ⟨t, rfl⟩ u ⟨v, rfl⟩ hne
  refine ⟨t ∪ v, ?_⟩
  ext x
  constructor
  · intro hx
    have hx' : ∀ i, i ∈ t ∪ v → x ∈ natGen Ω i := by
      simpa [piNatGen] using hx
    have ht : x ∈ piNatGen (Ω := Ω) t := by
      refine (by
        simpa [piNatGen] using (show ∀ i, i ∈ t → x ∈ natGen Ω i from
          fun i hi => hx' i (by simp [Finset.mem_union, hi])))
    have hv : x ∈ piNatGen (Ω := Ω) v := by
      simpa [piNatGen] using (show ∀ i, i ∈ v → x ∈ natGen Ω i from
        fun i hi => hx' i (by simp [Finset.mem_union, hi]))
    exact ⟨ht, hv⟩
  · rintro ⟨ht, hv⟩
    have ht' : ∀ i, i ∈ t → x ∈ natGen Ω i := by simpa [piNatGen] using ht
    have hv' : ∀ i, i ∈ v → x ∈ natGen Ω i := by simpa [piNatGen] using hv
    simpa [piNatGen] using (show ∀ i, i ∈ t ∪ v → x ∈ natGen Ω i from
      fun i hi => by
        have : i ∈ t ∨ i ∈ v := by simpa [Finset.mem_union] using hi
        rcases this with hi | hi
        · exact ht' i hi
        · exact hv' i hi)

lemma generateFrom_piNatGenSet :
    MeasurableSpace.generateFrom (piNatGenSet Ω) = (‹MeasurableSpace Ω›) := by
  have hle : MeasurableSpace.generateFrom (piNatGenSet Ω) ≤ (‹MeasurableSpace Ω›) := by
    refine MeasurableSpace.generateFrom_le ?_
    rintro _ ⟨t, rfl⟩
    exact measurableSet_piNatGen (Ω := Ω) t
  have hsub : Set.range (natGen Ω) ⊆ piNatGenSet Ω := by
    intro s hs
    rcases hs with ⟨n, rfl⟩
    refine ⟨{n}, ?_⟩
    ext x
    simp [piNatGen, natGen]
  have hge :
      (‹MeasurableSpace Ω›) ≤ MeasurableSpace.generateFrom (piNatGenSet Ω) := by
    have : MeasurableSpace.generateFrom (Set.range (natGen Ω)) =
        (‹MeasurableSpace Ω›) := by
      simpa [natGen] using (MeasurableSpace.generateFrom_natGeneratingSequence (α := Ω))
    have hmono :
        MeasurableSpace.generateFrom (Set.range (natGen Ω))
          ≤ MeasurableSpace.generateFrom (piNatGenSet Ω) :=
      MeasurableSpace.generateFrom_mono hsub
    simpa [this] using hmono
  exact le_antisymm hle hge

end CorePiSystem

end GibbsMeasure

end MeasureTheory
