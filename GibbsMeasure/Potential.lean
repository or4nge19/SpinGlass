import GibbsMeasure.Specification
import Mathlib.Analysis.SpecialFunctions.Exp
import Mathlib.Algebra.BigOperators.Ring.Finset
import Mathlib.Data.Set.Finite.Lattice

/-!
# Potentials and Gibbs specifications (finitary, interacting case)

This file introduces **interaction potentials**
and (an approximation to) the **Gibbs specification** obtained by modifying the independent
specification (`Specification.isssd`) by Boltzmann weights.

At this stage we focus on the *algebraic* side of the construction:

- `Potential`: a family `Φ Δ : (S → E) → ℝ` indexed by finite interaction supports `Δ : Finset S`.
- `Potential.IsPotential`: locality/measurability of each `Φ Δ` w.r.t. `cylinderEvents Δ`.
- `Potential.IsFinitary`: only finitely many interaction terms are non-zero.
- `Potential.interactingHamiltonian`: finite-volume interacting Hamiltonian
  \(H^{int}_Λ(η) = \sum_{Δ ∩ Λ ≠ ∅} Φ_Δ(η)\).
- `Potential.boltzmannWeight`: unnormalized Boltzmann weights `exp (-β H^{int}_Λ(η))` valued in `ℝ≥0∞`.
- `Potential.isPremodifier_boltzmannWeight`: the cocycle identity (Georgii 4.6), expressed as
  `Specification.IsPremodifier`.

Defining the *normalized* modifier (via the partition function) is straightforward; the genuinely
nontrivial step is proving the **consistency** of the normalized family. In this repo we do prove
consistency abstractly (`Specification.IsPremodifier.isModifier_premodifierNorm`) under the honest
nondegeneracy hypotheses `Z ≠ 0` and `Z ≠ ⊤`, and we apply it here to Boltzmann weights.
-/

open scoped BigOperators

open Set Finset MeasureTheory ENNReal

variable {S E : Type*} [MeasurableSpace E]

/-- A (multi-body) interaction potential: a family of real-valued functions indexed by finite
subsets of `S`. -/
def Potential (S E : Type*) [MeasurableSpace E] : Type _ :=
  (Δ : Finset S) → (S → E) → ℝ

namespace Potential

variable (Φ : Potential S E)

/-- A potential is *admissible* if each interaction term `Φ Δ` is measurable with respect to the
σ-algebra generated by the coordinates in `Δ`. -/
class IsPotential (Φ : Potential S E) : Prop where
  measurable (Δ : Finset S) :
    Measurable[cylinderEvents (X := fun _ : S ↦ E) (Δ : Set S)] (Φ Δ)

/-- A potential is *finitary* if only finitely many interaction terms are non-zero. This avoids any
analytic summability issues: all Hamiltonians we define are finite sums. -/
class IsFinitary (Φ : Potential S E) : Prop where
  finite_support : ( {Δ : Finset S | Φ Δ ≠ 0} ).Finite

section Locality

variable {Φ}

/-- If a real-valued function is measurable w.r.t. `cylinderEvents Δ`, then it depends only on the
coordinates in `Δ`. -/
lemma IsPotential.eq_of_eqOn [IsPotential Φ] {Δ : Finset S} {η ζ : S → E}
    (h : ∀ x ∈ Δ, η x = ζ x) :
    Φ Δ η = Φ Δ ζ := by
  classical
  have hf :
      Measurable[cylinderEvents (X := fun _ : S ↦ E) (Δ : Set S)] (Φ Δ) :=
    IsPotential.measurable (Φ := Φ) Δ
  -- Use the preimage of the singleton `{Φ Δ η}` and the fact that `cylinderEvents Δ` is a comap.
  have hA :
      MeasurableSet[cylinderEvents (X := fun _ : S ↦ E) (Δ : Set S)]
        ((Φ Δ) ⁻¹' {Φ Δ η}) := by
    exact hf (measurableSet_singleton _)
  have hA' :
      MeasurableSet[
          MeasurableSpace.comap (Set.restrict (π := fun _ : S ↦ E) (Δ : Set S))
            (inferInstance : MeasurableSpace (Δ → E))]
        ((Φ Δ) ⁻¹' {Φ Δ η}) := by
    simpa [cylinderEvents_eq_comap_restrict (S := S) (E := E) (Δ := (Δ : Set S))] using hA
  rcases hA' with ⟨B, hB, hpreim⟩
  have hη_mem : η ∈ (Set.restrict (π := fun _ : S ↦ E) (Δ : Set S)) ⁻¹' B := by
    -- `η ∈ (Φ Δ) ⁻¹' {Φ Δ η}` is trivial, then rewrite by `hpreim`.
    have : η ∈ ((Φ Δ) ⁻¹' {Φ Δ η}) := by simp
    simp [hpreim]
  have hre : Set.restrict (π := fun _ : S ↦ E) (Δ : Set S) η =
      Set.restrict (π := fun _ : S ↦ E) (Δ : Set S) ζ := by
    funext x
    exact h x x.2
  have hζ_mem : ζ ∈ (Set.restrict (π := fun _ : S ↦ E) (Δ : Set S)) ⁻¹' B := by
    -- transport membership along `hre`
    -- (unfold membership in a preimage)
    simpa [Set.mem_preimage, hre] using (show Set.restrict (π := fun _ : S ↦ E) (Δ : Set S) η ∈ B by
      simpa [Set.mem_preimage] using hη_mem)
  have : ζ ∈ ((Φ Δ) ⁻¹' {Φ Δ η}) := by
    simpa [hpreim] using hζ_mem
  exact (by
    -- Membership in the singleton preimage gives `Φ Δ ζ = Φ Δ η`; flip it to match the statement.
    simpa [Set.mem_preimage] using this : Φ Δ ζ = Φ Δ η).symm

end Locality

section InteractingHamiltonian

variable [DecidableEq S]
variable {Φ}

/-- The interacting Hamiltonian in a volume `Λ`: sum of all interaction terms whose support meets
`Λ`.

This is the standard finite-volume Hamiltonian \(H^{int}_Λ(η) = \sum_{Δ : Δ ∩ Λ ≠ ∅} Φ_Δ(η)\).
The finitary assumption ensures this is a finite sum. -/
noncomputable def interactingHamiltonian [IsFinitary Φ] (Λ : Finset S) (η : S → E) : ℝ :=
  let supp := (IsFinitary.finite_support (Φ := Φ)).toFinset
  Finset.sum (supp.filter (fun Δ => Δ ∩ Λ ≠ ∅)) (fun Δ => Φ Δ η)

lemma measurable_interactingHamiltonian [IsFinitary Φ] [IsPotential Φ] (Λ : Finset S) :
    Measurable (interactingHamiltonian (Φ := Φ) Λ) := by
  classical
  -- Finite sum of measurable functions (prove by `Finset` induction; `Measurable.sum` is not
  -- available in this Mathlib version).
  --simp [interactingHamiltonian]
  set t : Finset (Finset S) :=
      ((IsFinitary.finite_support (Φ := Φ)).toFinset).filter (fun Δ => Δ ∩ Λ ≠ ∅) with ht
  -- Reduce to the explicit finite sum over `t`.
  change Measurable (fun η : S → E => Finset.sum t (fun Δ => Φ Δ η))
  -- Induction on `t`.
  refine Finset.induction_on t ?_ ?_
  · simp
  · intro a s ha hs_meas
    have ha_meas : Measurable (fun η : S → E => Φ a η) :=
      (IsPotential.measurable (Φ := Φ) a).mono
        (cylinderEvents_le_pi (X := fun _ : S ↦ E) (Δ := (a : Set S))) le_rfl
    simpa [Finset.sum_insert ha] using ha_meas.add hs_meas

/-! ### Boltzmann weights and the cocycle identity -/

/-- Unnormalized Boltzmann weight `ρ_Λ(η) = exp (-β H^{int}_Λ(η))`, valued in `ℝ≥0∞`. -/
noncomputable def boltzmannWeight [IsFinitary Φ] (β : ℝ) (Λ : Finset S) (η : S → E) : ℝ≥0∞ :=
  ENNReal.ofReal (Real.exp (-β * interactingHamiltonian (Φ := Φ) Λ η))

lemma measurable_boltzmannWeight [IsFinitary Φ] [IsPotential Φ] (β : ℝ) (Λ : Finset S) :
    Measurable (boltzmannWeight (Φ := Φ) β Λ) := by
  -- Build measurability from `measurable_interactingHamiltonian`.
  have hH : Measurable fun η : S → E => interactingHamiltonian (Φ := Φ) Λ η :=
    measurable_interactingHamiltonian (Φ := Φ) Λ
  -- `η ↦ Real.exp (-β * H η)` is measurable, then map through `ENNReal.ofReal`.
  -- (`Real.exp` is measurable; multiplication by a constant is measurable.)
  simpa [boltzmannWeight] using
    (((measurable_const.mul hH).exp).ennreal_ofReal)

/-- The cocycle identity for interacting Boltzmann weights (Georgii identity 4.6), packaged as
`Specification.IsPremodifier`. -/
lemma isPremodifier_boltzmannWeight (β : ℝ) [IsFinitary Φ] [IsPotential Φ] :
    Specification.IsPremodifier (S := S) (E := E) (boltzmannWeight (Φ := Φ) β) := by
  classical
  refine ⟨?_, ?_⟩
  · intro Λ
    exact measurable_boltzmannWeight (Φ := Φ) β Λ
  · intro Λ₁ Λ₂ ζ η hΛ hrestrict
    -- Shorthand.
    let supp : Finset (Finset S) := (IsFinitary.finite_support (Φ := Φ)).toFinset
    let F (Λ : Finset S) : Finset (Finset S) := supp.filter fun Δ => Δ ∩ Λ ≠ ∅
    let H (Λ : Finset S) (σ : S → E) : ℝ := interactingHamiltonian (Φ := Φ) Λ σ

    have hHdiff (Λ : Finset S) :
        H Λ η - H Λ ζ = Finset.sum (F Λ) (fun Δ => Φ Δ η - Φ Δ ζ) := by
      -- distribute subtraction over the finite sum.
      -- `sum_sub_distrib` is stated in the opposite direction.
      simp [H, interactingHamiltonian, F, supp]

    have hFsubset : F Λ₁ ⊆ F Λ₂ := by
      intro Δ hΔ
      have hΔ' := Finset.mem_filter.1 hΔ
      refine Finset.mem_filter.2 ?_
      refine ⟨hΔ'.1, ?_⟩
      -- `Δ ∩ Λ₁ ≠ ∅` implies `Δ ∩ Λ₂ ≠ ∅` since `Λ₁ ⊆ Λ₂`.
      rcases (Finset.nonempty_iff_ne_empty.2 hΔ'.2) with ⟨x, hx⟩
      have hxΔ : x ∈ Δ := (Finset.mem_inter.1 hx).1
      have hxΛ₁ : x ∈ Λ₁ := (Finset.mem_inter.1 hx).2
      have hxΛ₂ : x ∈ Λ₂ := hΛ hxΛ₁
      -- Provide a witness in `Δ ∩ Λ₂`.
      exact (Finset.nonempty_iff_ne_empty).1 ⟨x, Finset.mem_inter.2 ⟨hxΔ, hxΛ₂⟩⟩

    have hsum :
        Finset.sum (F Λ₁) (fun Δ => Φ Δ η - Φ Δ ζ) =
          Finset.sum (F Λ₂) (fun Δ => Φ Δ η - Φ Δ ζ) := by
      -- Terms in `F Λ₂ \ F Λ₁` correspond to interactions disjoint from `Λ₁`, hence supported in `Λ₁ᶜ`,
      -- so they cancel because `η` and `ζ` agree outside `Λ₁`.
      refine Finset.sum_subset hFsubset ?_
      intro Δ hΔ_F₂ hΔ_not_F₁
      have hΔ_supp : Δ ∈ supp := (Finset.mem_filter.1 hΔ_F₂).1
      have hΔ_inter1_empty : Δ ∩ Λ₁ = ∅ := by
        by_contra hne
        have hne' : Δ ∩ Λ₁ ≠ ∅ := by simpa using hne
        have : Δ ∈ F Λ₁ := Finset.mem_filter.2 ⟨hΔ_supp, hne'⟩
        exact hΔ_not_F₁ this
      have hΔ_out : ∀ x ∈ Δ, x ∉ Λ₁ := by
        intro x hxΔ hxΛ₁
        have : x ∈ Δ ∩ Λ₁ := Finset.mem_inter.2 ⟨hxΔ, hxΛ₁⟩
        simp [hΔ_inter1_empty] at this
      have hΦΔ : Φ Δ η = Φ Δ ζ := by
        -- `Φ Δ` depends only on the coordinates in `Δ`.
        apply IsPotential.eq_of_eqOn (Φ := Φ) (Δ := Δ) (η := η) (ζ := ζ)
        intro x hxΔ
        have hx_not : x ∉ Λ₁ := hΔ_out x hxΔ
        -- `hrestrict` gives `ζ x = η x` outside `Λ₁`.
        simpa using (hrestrict x hx_not).symm
      -- Hence the difference term vanishes.
      simp [hΦΔ]

    have hdiff : H Λ₁ η - H Λ₁ ζ = H Λ₂ η - H Λ₂ ζ := by
      simp [hHdiff, hsum]

    have hsumH : H Λ₂ ζ + H Λ₁ η = H Λ₁ ζ + H Λ₂ η := by
      -- `a - b = c - d` implies `d + a = b + c`.
      have : H Λ₁ η + H Λ₂ ζ = H Λ₂ η + H Λ₁ ζ :=
        (sub_eq_sub_iff_add_eq_add).1 hdiff
      -- Commute the additions to match the desired order.
      calc
        H Λ₂ ζ + H Λ₁ η = H Λ₁ η + H Λ₂ ζ := by simp [add_comm]
        _ = H Λ₂ η + H Λ₁ ζ := this
        _ = H Λ₁ ζ + H Λ₂ η := by simp [add_comm]

    -- Turn the Hamiltonian identity into an identity of Boltzmann weights.
    -- We use `exp_add` and `ENNReal.ofReal_mul`.
    have h_exp :
        Real.exp (-β * H Λ₂ ζ) * Real.exp (-β * H Λ₁ η) =
          Real.exp (-β * H Λ₁ ζ) * Real.exp (-β * H Λ₂ η) := by
      have hexpArg :
          (-β * H Λ₂ ζ) + (-β * H Λ₁ η) = (-β * H Λ₁ ζ) + (-β * H Λ₂ η) := by
        -- Multiply `hsumH` by `(-β)` and expand with `mul_add`.
        have hmul : (-β) * (H Λ₂ ζ + H Λ₁ η) = (-β) * (H Λ₁ ζ + H Λ₂ η) :=
          congrArg (fun x => (-β) * x) hsumH
        simpa [mul_add, add_comm, add_left_comm, add_assoc, mul_assoc] using hmul
      calc
        Real.exp (-β * H Λ₂ ζ) * Real.exp (-β * H Λ₁ η)
            = Real.exp ((-β * H Λ₂ ζ) + (-β * H Λ₁ η)) := by
                simpa using (Real.exp_add (-β * H Λ₂ ζ) (-β * H Λ₁ η)).symm
        _ = Real.exp ((-β * H Λ₁ ζ) + (-β * H Λ₂ η)) := by
              exact congrArg Real.exp hexpArg
        _ = Real.exp (-β * H Λ₁ ζ) * Real.exp (-β * H Λ₂ η) := by
              simpa using (Real.exp_add (-β * H Λ₁ ζ) (-β * H Λ₂ η))

    -- Now lift `h_exp` through `ENNReal.ofReal` and rewrite products.
    dsimp [boltzmannWeight]
    calc
      ENNReal.ofReal (Real.exp (-β * H Λ₂ ζ)) * ENNReal.ofReal (Real.exp (-β * H Λ₁ η))
          = ENNReal.ofReal (Real.exp (-β * H Λ₂ ζ) * Real.exp (-β * H Λ₁ η)) := by
              have hnonneg : 0 ≤ Real.exp (-β * H Λ₂ ζ) := (Real.exp_pos _).le
              simpa using
                (ENNReal.ofReal_mul (p := Real.exp (-β * H Λ₂ ζ))
                    (q := Real.exp (-β * H Λ₁ η)) hnonneg).symm
      _ = ENNReal.ofReal (Real.exp (-β * H Λ₁ ζ) * Real.exp (-β * H Λ₂ η)) := by
            simpa using congrArg ENNReal.ofReal h_exp
      _ = ENNReal.ofReal (Real.exp (-β * H Λ₁ ζ)) * ENNReal.ofReal (Real.exp (-β * H Λ₂ η)) := by
            have hnonneg : 0 ≤ Real.exp (-β * H Λ₁ ζ) := (Real.exp_pos _).le
            simpa using
              (ENNReal.ofReal_mul (p := Real.exp (-β * H Λ₁ ζ))
                  (q := Real.exp (-β * H Λ₂ η)) hnonneg)

/-! ### Normalization (definition only) -/

section Normalization

/-- The **partition function** (normalizing factor) for the Boltzmann weights in volume `Λ` with
boundary condition `η`. This is just `Specification.premodifierZ` specialized to the Boltzmann
premodifier. -/
noncomputable def partitionFunction (Φ : Potential S E) [IsFinitary Φ]
    (β : ℝ) (ν : Measure E) [IsProbabilityMeasure ν] (Λ : Finset S) (η : S → E) : ℝ≥0∞ :=
  Specification.premodifierZ (S := S) (E := E) ν (boltzmannWeight (Φ := Φ) β) Λ η

lemma measurable_partitionFunction (Φ : Potential S E) [IsFinitary Φ] [IsPotential Φ]
    (β : ℝ) (ν : Measure E) [IsProbabilityMeasure ν] (Λ : Finset S) :
    Measurable[cylinderEvents (X := fun _ : S ↦ E) (Λ : Set S)ᶜ]
      (partitionFunction (S := S) (E := E) Φ β ν Λ) := by
  -- Kernel-measurability of `isssd` gives boundary-measurability of the lintegral.
  simpa [partitionFunction, Specification.premodifierZ] using
    (Measurable.lintegral_kernel
      (κ := (Specification.isssd (S := S) (E := E) ν Λ))
      (f := boltzmannWeight (Φ := Φ) β Λ)
      (measurable_boltzmannWeight (S := S) (E := E) (Φ := Φ) β Λ))

/-- The (normalized) Gibbs modifier associated to the Boltzmann weights, i.e.
\(\rho'_Λ(η) = \rho_Λ(η) / \int \rho_Λ \, d(\text{isssd}_Λ(η))\). -/
noncomputable def gibbsModifier (Φ : Potential S E) [IsFinitary Φ]
    (β : ℝ) (ν : Measure E) [IsProbabilityMeasure ν] (Λ : Finset S) (η : S → E) : ℝ≥0∞ :=
  boltzmannWeight (Φ := Φ) β Λ η /
    partitionFunction (S := S) (E := E) Φ β ν Λ η

lemma measurable_gibbsModifier (Φ : Potential S E) [IsFinitary Φ] [IsPotential Φ]
    (β : ℝ) (ν : Measure E) [IsProbabilityMeasure ν] (Λ : Finset S) :
    Measurable (gibbsModifier (S := S) (E := E) Φ β ν Λ) := by
  -- Use the general lemma `Specification.IsPremodifier.measurable_div_isssd`.
  have hpre : Specification.IsPremodifier (S := S) (E := E) (boltzmannWeight (Φ := Φ) β) :=
    isPremodifier_boltzmannWeight (Φ := Φ) β
  simpa [gibbsModifier, partitionFunction, Specification.premodifierZ, div_eq_mul_inv] using
    (hpre.measurable_div_isssd (ρ := boltzmannWeight (Φ := Φ) β) ν Λ)

/-- `gibbsModifier` is definitionaly the normalized premodifier `premodifierNorm` applied to the
Boltzmann weights. -/
lemma gibbsModifier_eq_premodifierNorm (Φ : Potential S E) [IsFinitary Φ]
    (β : ℝ) (ν : Measure E) [IsProbabilityMeasure ν] :
    gibbsModifier (S := S) (E := E) Φ β ν
      = Specification.premodifierNorm (S := S) (E := E) ν (boltzmannWeight (Φ := Φ) β) := by
  funext Λ η
  simp [gibbsModifier, partitionFunction, Specification.premodifierNorm, Specification.premodifierZ]

/-- The partition function for Boltzmann weights is never `0` (since the weight is strictly
positive everywhere and `isssd` is a probability measure). -/
lemma premodifierZ_boltzmannWeight_ne_zero (Φ : Potential S E) [IsFinitary Φ] [IsPotential Φ]
    (β : ℝ) (ν : Measure E) [IsProbabilityMeasure ν] (Λ : Finset S) (η : S → E) :
    Specification.premodifierZ (S := S) (E := E) ν (boltzmannWeight (Φ := Φ) β) Λ η ≠ 0 := by
  classical
  -- Let `μ` be the resampling measure in volume `Λ`.
  let μ : Measure (S → E) := Specification.isssd (S := S) (E := E) ν Λ η
  have hμ_univ : μ Set.univ = 1 := by
    simpa [μ] using (IsProbabilityMeasure.measure_univ (μ := Specification.isssd (S := S) (E := E) ν Λ η))
  have hf_meas : Measurable (boltzmannWeight (Φ := Φ) β Λ) :=
    measurable_boltzmannWeight (Φ := Φ) β Λ
  have hsupport : Function.support (boltzmannWeight (Φ := Φ) β Λ) = Set.univ := by
    ext x
    simp [boltzmannWeight, Real.exp_pos]
  -- `0 < ∫ f` since `μ(support f) = 1`.
  have hpos :
      (0 : ℝ≥0∞) < ∫⁻ x, boltzmannWeight (Φ := Φ) β Λ x ∂μ := by
    have : (0 : ℝ≥0∞) < μ (Function.support (boltzmannWeight (Φ := Φ) β Λ)) := by
      -- support is `univ`
      simp [hsupport, hμ_univ]
    exact (MeasureTheory.lintegral_pos_iff_support hf_meas).2 this
  -- Conclude.
  simpa [Specification.premodifierZ, μ] using (ne_of_gt hpos)

/-- The partition function for Boltzmann weights is never `0`. -/
lemma partitionFunction_ne_zero (Φ : Potential S E) [IsFinitary Φ] [IsPotential Φ]
    (β : ℝ) (ν : Measure E) [IsProbabilityMeasure ν] (Λ : Finset S) (η : S → E) :
    partitionFunction (S := S) (E := E) Φ β ν Λ η ≠ 0 := by
  simpa [partitionFunction] using
    (premodifierZ_boltzmannWeight_ne_zero (S := S) (E := E) (Φ := Φ) β ν Λ η)

/-- Under the nondegeneracy assumption `Z ≠ ⊤`, the Gibbs modifier is an actual modifier for `isssd`
(consistency holds). -/
lemma isModifier_gibbsModifier (Φ : Potential S E) [IsFinitary Φ] [IsPotential Φ]
    (β : ℝ) (ν : Measure E) [IsProbabilityMeasure ν]
    (hZ : ∀ (Λ : Finset S) (η : S → E),
      Specification.premodifierZ (S := S) (E := E) ν (boltzmannWeight (Φ := Φ) β) Λ η ≠ ⊤) :
    (Specification.isssd (S := S) (E := E) ν).IsModifier (gibbsModifier (S := S) (E := E) Φ β ν) := by
  classical
  let ρ : Finset S → (S → E) → ℝ≥0∞ := boltzmannWeight (Φ := Φ) β
  have hpre : Specification.IsPremodifier (S := S) (E := E) ρ :=
    isPremodifier_boltzmannWeight (Φ := Φ) β
  have hZ' :
      ∀ (Λ : Finset S) (η : S → E),
        Specification.premodifierZ (S := S) (E := E) ν ρ Λ η ≠ 0 ∧
          Specification.premodifierZ (S := S) (E := E) ν ρ Λ η ≠ ⊤ := by
    intro Λ η
    refine ⟨?_, ?_⟩
    · simpa [ρ] using premodifierZ_boltzmannWeight_ne_zero (S := S) (E := E) (Φ := Φ) β ν Λ η
    · simpa [ρ] using hZ Λ η
  have hmod' :
      (Specification.isssd (S := S) (E := E) ν).IsModifier
        (Specification.premodifierNorm (S := S) (E := E) ν ρ) :=
    Specification.IsPremodifier.isModifier_premodifierNorm (S := S) (E := E) (ν := ν) (ρ := ρ) hpre hZ'
  -- Rewrite `premodifierNorm` as `gibbsModifier`.
  simpa [gibbsModifier_eq_premodifierNorm (S := S) (E := E) (Φ := Φ) β ν, ρ] using hmod'

/-- The Gibbs specification associated to a potential: the modification of the independent
specification by the *normalized* Boltzmann weights.

We must assume the partition functions are finite (`Z ≠ ⊤`) to normalize in `ℝ≥0∞`. -/
noncomputable def gibbsSpecification (Φ : Potential S E) [IsFinitary Φ] [IsPotential Φ]
    (β : ℝ) (ν : Measure E) [IsProbabilityMeasure ν]
    (hZ : ∀ (Λ : Finset S) (η : S → E),
      Specification.premodifierZ (S := S) (E := E) ν (boltzmannWeight (Φ := Φ) β) Λ η ≠ ⊤) :
    Specification S E :=
  (Specification.isssd (S := S) (E := E) ν).modification
    (gibbsModifier (S := S) (E := E) Φ β ν)
    (isModifier_gibbsModifier (S := S) (E := E) (Φ := Φ) β ν hZ)

end Normalization
end InteractingHamiltonian

end Potential
